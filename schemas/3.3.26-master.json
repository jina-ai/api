{"$id": "https://api.jina.ai/schemas/3.3.26.json", "$schema": "http://json-schema.org/draft-07/schema#", "definitions": {"Jina::Deployment": {"additionalProperties": false, "description": "Define the config of a Deployment.", "items": {"minItems": 1, "type": "string", "uniqueItems": true}, "properties": {"compression": {"default": "NoCompression", "description": "The compression mechanism used when sending requests from the Head to the WorkerRuntimes. Possibilities are `NoCompression, Gzip, Deflate`. For more details, check https://grpc.github.io/grpc/python/grpc.html#compression.", "type": "string"}, "connection_list": {"default": null, "description": "dictionary JSON with a list of connections to configure", "type": "string"}, "disable_auto_volume": {"default": false, "description": "Do not automatically mount a volume for dockerized Executors.", "type": "boolean"}, "disable_reduce": {"default": false, "description": "Disable the built-in reduce mechanism, set this if the reduction is to be handled by the Executor connected to this Head", "type": "boolean"}, "docker_kwargs": {"default": null, "description": "Dictionary of kwargs arguments that will be passed to Docker SDK when starting the docker '\ncontainer. \n\nMore details can be found in the Docker SDK docs:  https://docker-py.readthedocs.io/en/stable/", "type": "object"}, "entrypoint": {"default": null, "description": "The entrypoint command overrides the ENTRYPOINT in Docker image. when not set then the Docker image ENTRYPOINT takes effective.", "type": "string"}, "env": {"default": null, "description": "The map of environment variables that are available inside runtime", "type": "object"}, "external": {"default": false, "description": "The Deployment will be considered an external Deployment that has been started independently from the Flow.This Deployment will not be context managed by the Flow.", "type": "boolean"}, "force_update": {"default": false, "description": "If set, always pull the latest Hub Executor bundle even it exists on local", "type": "boolean"}, "gpus": {"default": null, "description": "This argument allows dockerized Jina executor discover local gpu devices.\n\n    Note, \n    - To access all gpus, use `--gpus all`.\n    - To access multiple gpus, e.g. make use of 2 gpus, use `--gpus 2`.\n    - To access specified gpus based on device id, use `--gpus device=[YOUR-GPU-DEVICE-ID]`\n    - To access specified gpus based on multiple device id, use `--gpus device=[YOUR-GPU-DEVICE-ID1],device=[YOUR-GPU-DEVICE-ID2]`\n    - To specify more parameters, use `--gpus device=[YOUR-GPU-DEVICE-ID],runtime=nvidia,capabilities=display", "type": "string"}, "host": {"default": "0.0.0.0", "description": "The host address of the runtime, by default it is 0.0.0.0.", "type": "string"}, "host_in": {"default": "0.0.0.0", "description": "The host address for binding to, by default it is 0.0.0.0", "type": "string"}, "install_requirements": {"default": false, "description": "If set, install `requirements.txt` in the Hub Executor bundle to local", "type": "boolean"}, "log_config": {"default": "default", "description": "The YAML config of the logger used in this object.", "type": "string"}, "method": {"default": "add", "description": "The method to use when appending the Deployment to the Flow", "enum": ["add", "needs", "inspect", "needs_all", "gather_inspect"], "type": "string"}, "monitoring": {"default": false, "description": "If set, spawn an http server with a prometheus endpoint to expose metrics", "type": "boolean"}, "name": {"default": null, "description": "The name of this object.\n\n    This will be used in the following places:\n    - how you refer to this object in Python/YAML/CLI\n    - visualization\n    - log message header\n    - ...\n\n    When not given, then the default naming strategy will apply.", "type": "string"}, "native": {"default": false, "description": "If set, only native Executors is allowed, and the Executor is always run inside WorkerRuntime.", "type": "boolean"}, "needs": {"description": "The name of the Deployment(s) that this Deployment receives data from. One can also use `gateway` to indicate the connection with the gateway.\nThis is useful to create parallelization. By default the Flow always works sequentially following the defined order of the Deployments.", "items": {"minItems": 1, "type": "string", "uniqueItems": true}, "type": ["array", "string"]}, "output_array_type": {"default": null, "description": "The type of array `tensor` and `embedding` will be serialized to.\n\nSupports the same types as `docarray.to_protobuf(.., ndarray_type=...)`, which can be found \n`here <https://docarray.jina.ai/fundamentals/document/serialization/#from-to-protobuf>`.\nDefaults to retaining whatever type is returned by the Executor.", "type": "string"}, "polling": {"default": "ANY", "description": "The polling strategy of the Deployment and its endpoints (when `shards>1`).\n    Can be defined for all endpoints of a Deployment or by endpoint.\n    Define per Deployment:\n    - ANY: only one (whoever is idle) Pod polls the message\n    - ALL: all Pods poll the message (like a broadcast)\n    Define per Endpoint:\n    JSON dict, {endpoint: PollingType}\n    {'/custom': 'ALL', '/search': 'ANY', '*': 'ANY'}", "type": "string"}, "port": {"default": 55283, "description": "The port for input data to bind to, default is a random port between [49152, 65535]", "type": "number"}, "port_monitoring": {"default": 9090, "description": "The port on which the prometheus server is exposed, default port is 9090", "type": "number"}, "py_modules": {"default": null, "description": "The customized python modules need to be imported before loading the executor\n\nNote that the recommended way is to only import a single module - a simple python file, if your\nexecutor can be defined in a single file, or an ``__init__.py`` file if you have multiple files,\nwhich should be structured as a python package. For more details, please see the\n`Executor cookbook <https://docs.jina.ai/fundamentals/executor/repository-structure/>`__", "type": "array"}, "quiet": {"default": false, "description": "If set, then no log will be emitted from this object.", "type": "boolean"}, "quiet_error": {"default": false, "description": "If set, then exception stack information will not be added to the log", "type": "boolean"}, "quiet_remote_logs": {"default": false, "description": "Do not display the streaming of remote logs on local console", "type": "boolean"}, "replicas": {"default": 1, "description": "The number of replicas in the deployment", "type": "number"}, "runtime_cls": {"default": "WorkerRuntime", "description": "The runtime class to run inside the Pod", "type": "string"}, "shards": {"default": 1, "description": "The number of shards in the deployment running at the same time. For more details check https://docs.jina.ai/fundamentals/flow/create-flow/#complex-flow-topologies", "type": "number"}, "timeout_ctrl": {"default": 60, "description": "The timeout in milliseconds of the control request, -1 for waiting forever", "type": "number"}, "timeout_ready": {"default": 600000, "description": "The timeout in milliseconds of a Pod waits for the runtime to be ready, -1 for waiting forever", "type": "number"}, "timeout_send": {"default": null, "description": "The timeout in milliseconds used when sending data requests to Executors, -1 means no timeout, disabled by default", "type": "number"}, "upload_files": {"default": null, "description": "The files on the host to be uploaded to the remote\nworkspace. This can be useful when your Deployment has more\nfile dependencies beyond a single YAML file, e.g.\nPython files, data files.\n\nNote,\n- currently only flatten structure is supported, which means if you upload `[./foo/a.py, ./foo/b.pp, ./bar/c.yml]`, then they will be put under the _same_ workspace on the remote, losing all hierarchies.\n- by default, `--uses` YAML file is always uploaded.\n- uploaded files are by default isolated across the runs. To ensure files are submitted to the same workspace across different runs, use `--workspace-id` to specify the workspace.", "type": "array"}, "uses": {"default": "BaseExecutor", "description": "The config of the executor, it could be one of the followings:\n        * an Executor YAML file (.yml, .yaml, .jaml)\n        * a Jina Hub Executor (must start with `jinahub://` or `jinahub+docker://`)\n        * a docker image (must start with `docker://`)\n        * the string literal of a YAML config (must start with `!` or `jtype: `)\n        * the string literal of a JSON config\n\n        When use it under Python, one can use the following values additionally:\n        - a Python dict that represents the config\n        - a text file stream has `.read()` interface", "type": "string"}, "uses_after": {"default": null, "description": "The executor attached after the Pods described by --uses, typically used for receiving from all shards, accepted type follows `--uses`. This argument only applies for sharded Deployments (shards > 1).", "type": "string"}, "uses_after_address": {"default": null, "description": "The address of the uses-before runtime", "type": "string"}, "uses_before": {"default": null, "description": "The executor attached before the Pods described by --uses, typically before sending to all shards, accepted type follows `--uses`. This argument only applies for sharded Deployments (shards > 1).", "type": "string"}, "uses_before_address": {"default": null, "description": "The address of the uses-before runtime", "type": "string"}, "uses_metas": {"default": null, "description": "Dictionary of keyword arguments that will override the `metas` configuration in `uses`", "type": "object"}, "uses_requests": {"default": null, "description": "Dictionary of keyword arguments that will override the `requests` configuration in `uses`", "type": "object"}, "uses_with": {"default": null, "description": "Dictionary of keyword arguments that will override the `with` configuration in `uses`", "type": "object"}, "volumes": {"default": null, "description": "The path on the host to be mounted inside the container. \n\nNote, \n- If separated by `:`, then the first part will be considered as the local host path and the second part is the path in the container system. \n- If no split provided, then the basename of that directory will be mounted into container's root path, e.g. `--volumes=\"/user/test/my-workspace\"` will be mounted into `/my-workspace` inside the container. \n- All volumes are mounted with read-write mode.", "type": "array"}, "when": {"default": null, "description": "The condition that the documents need to fulfill before reaching the Executor.The condition can be defined in the form of a `DocArray query condition <https://docarray.jina.ai/fundamentals/documentarray/find/#query-by-conditions>`", "type": "object"}, "workspace": {"default": null, "description": "The working directory for any IO operations in this object. If not set, then derive from its parent `workspace`.", "type": "string"}}, "required": [], "type": "object"}, "Jina::Executors::All": {"minItems": 1, "type": "array"}, "Jina::Flow": {"additionalProperties": false, "properties": {"executors": {"description": "Define the steps in the Flow.\nA Deployment is a container and interface for one or multiple Pods that have the same properties.", "items": {"$ref": "#/definitions/Jina::Deployment"}, "minItems": 1, "type": "array"}, "jtype": {"default": "Flow", "description": "The type of Jina object (Flow, Executor).\nA Flow is made up of several sub-tasks, and it manages the states and context of these sub-tasks.\nThe input and output data of Flows are Documents.", "enum": ["Flow"], "type": "string"}, "version": {"default": "'1'", "description": "The YAML version of this Flow.", "type": "string"}, "with": {"additionalProperties": false, "description": "The config of Flow, unrecognized config arguments will be applied to all Deployments", "properties": {"env": {"default": null, "description": "The map of environment variables that are available inside runtime", "type": "object"}, "inspect": {"default": "COLLECT", "description": "The strategy on those inspect deployments in the flow.\n\n    If `REMOVE` is given then all inspect deployments are removed when building the flow.", "enum": ["HANG", "REMOVE", "COLLECT"], "type": "string"}, "log_config": {"default": "default", "description": "The YAML config of the logger used in this object.", "type": "string"}, "name": {"default": null, "description": "The name of this object.\n\n    This will be used in the following places:\n    - how you refer to this object in Python/YAML/CLI\n    - visualization\n    - log message header\n    - ...\n\n    When not given, then the default naming strategy will apply.", "type": "string"}, "quiet": {"default": false, "description": "If set, then no log will be emitted from this object.", "type": "boolean"}, "quiet_error": {"default": false, "description": "If set, then exception stack information will not be added to the log", "type": "boolean"}, "uses": {"default": null, "description": "The YAML file represents a flow", "type": "string"}, "workspace": {"default": null, "description": "The working directory for any IO operations in this object. If not set, then derive from its parent `workspace`.", "type": "string"}}, "required": [], "type": "object"}}, "required": ["jtype", "version", "deployments"], "type": "object"}, "Jina::Metas": {"additionalProperties": false, "description": "The meta config of the Executor", "properties": {"description": {"default": null, "description": "The description of this executor. It will be used in automatics docs UI", "type": "string"}, "name": {"default": null, "description": "The name of the executor.", "type": "string"}, "py_modules": {"default": null, "description": "\nThe external python module paths. it is useful when you want to load external python modules\nusing :func:`BaseExecutor.load_config` from a YAML file. If a relative path is given then the root path is set to\nthe path of the current YAML file.\n\nExample of ``py_module`` usage:\n\n1. This is a valid structure and it is RECOMMENDED:\n    - \"my_cust_module\" is a python module\n    - all core logic of your customized executor goes to ``__init__.py``\n    - to import ``foo.py``, you can use relative import, e.g. ``from .foo import bar``\n    - ``helper.py`` needs to be put BEFORE `__init__.py` in YAML ``py_modules``\n\nThis is also the structure given by ``jina hub new`` CLI.\n\n    .. highlight:: text\n    .. code-block:: text\n\n         my_cust_module\n           |- __init__.py\n           |- helper.py\n           |- config.yml\n                |- py_modules\n                       |- helper.py\n                       |- __init__.py\n\n2. This is a valid structure but not recommended:\n    - \"my_cust_module\" is not a python module (lack of __init__.py under the root)\n    - to import ``foo.py``, you must to use ``from jinahub.foo import bar``\n    - ``jinahub`` is a common namespace for all plugin-modules, not changeable.\n    - ``helper.py`` needs to be put BEFORE `my_cust.py` in YAML ``py_modules``\n\n    .. highlight:: text\n    .. code-block:: text\n\n         my_cust_module\n           |- my_cust.py\n           |- helper.py\n           |- config.yml\n                |- py_modules\n                       |- helper.py\n                       |- my_cust.py                \n                ", "items": {"minItems": 1, "type": "string", "uniqueItems": true}, "type": "array"}}, "required": [], "type": "object"}}, "description": "The YAML schema of Jina objects (Flow, Executor).", "oneOf": [{"$ref": "#/definitions/Jina::Flow"}], "type": "object"}